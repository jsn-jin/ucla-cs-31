{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fmodern\fcharset0 Courier;\f2\fmodern\fcharset0 Courier-Bold;
}
{\colortbl;\red255\green255\blue255;\red251\green2\blue7;\red251\green2\blue255;\red127\green0\blue128;
\red127\green127\blue127;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c100000\c14913\c0;\cssrgb\c100000\c25279\c100000;\cssrgb\c57919\c12801\c57269;
\cssrgb\c57046\c57047\c57046;\cssrgb\c0\c0\c0;}
\margl1440\margr1440\vieww20560\viewh19280\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs36 \cf0 Nov. 19 - M - Lec 14\
\
	Pointer and Struct (continued)\

\f1 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx10793\pardirnatural\partightenfactor0

\f0 \cf0 # ----------------------------------------------------------------------- #
\f1 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
	&a[i] - &a[j] <===> i - j;		\
		\
	// This is legal. How far it is from pointer j to pointer i?\
\
	1000	1008	1016	1024...\
  	|				|\
\
	1016\
	1000\
	----\
  	  16 bytes.	// However, the compiler will divide the answer by 8 since a[k] is a double.\

\f0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx10793\pardirnatural\partightenfactor0
\cf0 ## ----------------------------------------------------------------------- ##\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1 \cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf2 	double*\cf0  findFirstNegative(double a[], int n)\
	\{\
		for (\cf2 double* p=a; p<a+n; p++\cf0 )\
		\{\
			if (\cf3 *p\cf0  < 0)\
			return \cf3 p\cf0 ;		// p is getting incremented. p = &a[0], &a[1], &a[2]...\
							// p = &a[2] equals &a[0] + 2. p = a, a+1, a+2...\
		\}\
		return \cf3 a + n or nullptr\cf0 ;		\
							// Pointer to the end of the array.\
							// An alternative return: null pointer.\
							// c++11: 
\f2\b nullptr
\f1\b0 \
							// Earlier: NULL (don\'92t use this)\
	\}\
\
	int main()\
	\{\
		double da[5];\
		...\
		\cf4 double* pfn\cf0  = findFirstNegative(da, 5);\
		if (\cf4 pfn == da + 5 or nullptr\cf0 )\
 			cout << "There are no negative values in the array" << endl;\
		else\
		\{\
			cout << "The first negative value is " << \cf4 *pfn \cf0 << endl;\
			cout << "It's ar element number " << \cf4 pfn - &da[0]\cf0  << endl;\
												    \cf5  //pfn - da\cf0 \
		\}\
	\}	\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0 \cf0 \
	
\f1 // What we get back from the function is a pointer to the element of the array.
\f0 \
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx10793\pardirnatural\partightenfactor0
\cf0 ## ----------------------------------------------------------------------- ##\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 	
\f1 	\
	// Below if the original function\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf2 	\cf3 int\cf0  findFirstNegative(double a[], int n)\
	\{\
		for (int k=0; k<n; k++)\
		\{\
			if (a[k] < 0)\
				return \cf3 k\cf0 ;\
		\}\
		return -1;\
	\}\
\
	int main()\
	\{\
		double da[5];\
		...\
		\cf4 int fnpos\cf0  = findFirstNegative(da, 5);\
		if (fnpos == -1)\
 			cout << "There are no negative values in the array" << endl;\
		else\
		\{\
			cout << "The first negative value is " << \cf3 da[fnpos] \cf0 << endl;\
			cout << "It's ar element number " << \cf3 fnpos\cf0  << endl;		\}\
	\}	\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx10793\pardirnatural\partightenfactor0

\f0 \cf0 ## ----------------------------------------------------------------------- ##\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx10793\pardirnatural\partightenfactor0

\f1 \cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 	double* p  = nullptr;\
	p = nullptr;\
	if (p == nullptr);\
	if (p != nullptr);\
\
	\cf2 *p ====> undefined behavior if p has the null pointer value.\cf0 \
\
	int* p1;\
	int* p2 = nullptr;\
\
	\'85 *p1 \'85	// Undefined behavior. p1 is not initialized. May crash or not.\
	\'85 *p2 \'85	// Undefined behavior. p2 has the null pointer value. The program crashes.\
	\
	null pointer: 0x000000 \

\f0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx10793\pardirnatural\partightenfactor0
\cf0 ## ----------------------------------------------------------------------- ##\
\
# --------------------------------------------------------------------------------- #\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1 \cf0 \
	struct Employee	\
	\{\
		string name;\
		double salary;\
		int age;\
\
	\}\cf2 ;\cf0  	\cf5 // <\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97 don\'92t forget this semi-colon.\cf0 \
\
	int main()\
	\{\
		Employee e1;	// In c++, it is called a data members.\
		Employee e2;	// Another employee;\
\
		e1.name = "Fred";\
		e1.salary = 60000;\
		e1.age = 50;\
	\
		e2.name = "Ethel";\
		e1.age++;\
	\
		cout << "Enter a name: ";\
		getline(cin, e2.name);\
\
		Employee company[100];\
		company[3].name = "Ricky";\
\
		for (int k = 0; k != company[3].name.size(); k++)\
			cout << company[3].name[k] << endl;			\cf5 // This will print the name vertically.\cf0 \
	\}	\

\f0 \
	\cf3 		An object				The name of\
			of some		.		a member of\
			struct type			that type\cf0 \
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx10793\pardirnatural\partightenfactor0
\cf0 ## ------------------------ Struct as A Parameter of Functions ------------------------ ##\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \

\f1 	struct Employee	\
	\{\
		string name;\
		double salary;\
		int age;\
	\};\
\
	void printPayCheck(\cf3 const\cf0  Employee\cf4 &\cf0  e);		\cf5 // My employee object will not be changed.\cf0 \
\
	void celebrateBirthday(Employee\cf3 &\cf0  e);	\
		\cf5 // Should not pass by a const reference\cf0 .\
\
	int main()\
	\{\
		Employee company[100];\
		int nEmployees = 0;\
		\cf5 //	... read in some information, fill some of the array, set nEmployees.\cf0 \
	\
		printPayCheck(company[0]);\
		celebrateBirthday(company[2]);\
	\}\
\
	void printPayCheck(\cf2 const\cf0  Employee\cf2 &\cf0  e)	\cf5 // If passing by value, expensive to copy the whole object, so use reference.\cf0 \
	\{\
		cout << "Pay to the order of " << e.name << " the amount $" << e.salary/12 << endl;\
	\}\
\
	void celebrateBirthday(Employee\cf2 &\cf0  e)	\cf5 // If we pass by value, Lucy\'92s age will not change.\cf0 \
	\{\
		e.age++;\
	\}\

\f0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx10793\pardirnatural\partightenfactor0
\cf0 ## ----------------------------------------------------------------------- ##\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \

\f1 	Caller's object should 
\f2\b not change
\f1\b0 :\
		\cf3 void f(Blah b)	\cf0 		\
		Pass by \cf4 values\cf0  		--------> Best if objects are cheap to copy \
											(What is cheap to copy? Built-in types: int, double...)\
\
		\cf3 void f(
\f2\b \cf3 const
\f1\b0 \cf3  Blah b)\cf0 	\
		Pass by \cf4 constant reference\cf2   \cf0  --------> Best if objects are not cheap to copy \
\
\
	Caller's object 
\f2\b should change
\f1\b0 \
		\cf3 void f(Blah b)\cf0 			\
		Pass by (non-constant) \cf4 reference\cf0 \
\
	// There is another we can pass something to function (pointer). (See Lec 15)\

\f0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx10793\pardirnatural\partightenfactor0
\cf0 ## ----------------------------------------------------------------------- ##\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
	
\f1 // Code
\f0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf6 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1 \cf6 	#include<iostream>\
	using namespace std;\
\
	struct Employee\
	\{\
		string name;\
		double salary;\
		int age;\
	\}\cf3 ;\cf6 \
\
	void printPayCheck(const Employee& e)\
	\{\
		cout << "Pay to the order of " << e.name << " the amount $" << e.salary/12 << endl;\
	\}\
\
	void celebrateBirthday(Employee& e)\
	\{\
		e.age++;\
	\}\
\
	int main()\
	\{\
		// We can construct an object here.\
		Employee e1;\
		Employee e2;\
\
		e1.name = "Fred";\
		e1.salary = 60000;\
		e1.age = 50;\
	\
		e2.name = "Ethel";\
		e1.age++;\
\
		Employee company[100];		\cf3 // each element can be treated like an object.\cf6 \
		company[0].name = "Jeff";\
		company[0].salary = 600;\
		company[0].age = 40;\
\
		printPayCheck(company[0]);\
		celebrateBirthday(company[0]);\
		cout << company[0].age;\
	\}\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0 \cf0 \
\
\
\
\
\
\
\
}